Aggregating streams:

find . | group ^size | aggr group={count}
find . | group ^user | aggr group={sum ^size}

Graphs:

Graphs consist of two data types: nodes and edges.

Crush nodes are simply rows in normal tables.

Crush edges are a new type that connect two table rows to each others. Every
edge contains two index references. Edges can be directed or undirected.
Edges can point to the same row or other rows in the same table, but allowing
them to point to rows in other tables would lead to reference cycles and memory
leaks. One-to-one relationships are simply edge fields. One-to-many, and many-to-many
relationships are modeled using fields of lists.

# Find leaf nodes
crush> ps | where { (children:len) == 0 }

A new operator, '::', is used to access a member in each element of a list.

# Find processes who are running as a different user than their parent
ps | where { parent::user != $user }

When using '::' on a list/set of edges, it fetches that member in each element in returns them in a new list.

In order to display a graph as a tree, simply return an edge as the root object, and the pretty-printer will
do the rest:

crush> (ps | where {pid = 1}):parent
...


grpc command:

#Create new grpc instance:
crush> srv := (grpc "localhost:443")
#List all services on a server
crush> dir srv
[my.service other.service]
#List all methods of a service
crush> dir srv:my.service
[method1 method2]
#Call method without parameters
srv:my.service:method1
["some" "output"]
#Call method with parameters
srv:my.service:method2 id=1234 tags=(list:of "foo" "bar")
["other" "output"]
