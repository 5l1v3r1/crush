Date mode:

# Now:
echo date{now}

# Five days into the future
echo date{now + five days}

# These are equivalent:
echo date{2012-03-30 16:32}
echo date{3/30/2012 4:32 PM}

Durations:

# One hour
echo duration{1 hour}

# Silly way to say one week
echo duration{6 days 23 hours 59 minutes 60 seconds}

Variable expansion in date/time environments:

let hour_count = 5
echo duration{$hour_count hours}

let unit = minutes
echo duration{7 $unit}

let timeout=duration{10 seconds}
let soft_deadline = date{now + $timeout}
let hard_deadline = date{now + $timeout*2}

More math with time:
# Subtract two timestamps to get a durations
let t1 = t{1970-01-01: 00:00:00}
let t2 = t{now}
let dur = t{$t2 - $t1}

Math mode:
Math mode inside math{}
echo math{5*5}
# 25
let foo=4
let bar=16
let large_number=math{$foo^bar}
Following operators supported + - * / ^ == != > < >= <= as well as parenthesis for grouping.

Integrating external commands:

Just pass thorugh commands that don't exist in the shell but exist in PATH

git grep fnurp

IO redirection:

???

Stream editing:

# Convert file column in-place
ls | upper file=%file

# Append new upper-column
ls | lower upper=%file

# Replace file column in-place using regex
ls | sed file=r{a(b*)c(d*)e}{\1\2}g

Extracting single cells from table output:

echo largest_file={ls|sort %size|reverse}[0][%size]

New list literal syntax

Use separate modes for lists and maps:

let my_list = list{1 2 3} list_of_list = list{ list{a} list{b c} list{d}}
let my_hash = map{sally: row{} john: row{first_name: John last_name: Smith age: 42}}

Modes:

regex{.*} # Regex
date{now} # Date (with time)
duration{1 hour 20 minutes} # Durations
list{1 2 3} # List literal
map{1:foo 5:bar 9:baz} # Map literal
math{5*5} # Math
*{*.txt} # Glob
`{ls} # Closure
{ls} # Command substitution

Problems:

How to mutate a list/map?

Possibility

> let my_list = list{1 2 3}
> list.push $my_list 4 5 6
> list.pop $my_list
value
6
> list.len $my_list
size
5

Another
> let my_list = list{1 2 3}
> list.push my_list 4 5 6
> list.pop my_list
value
6
> list.len my_list
5

Empty list:
> list.create empty_list integer

json deserialization:
How to deal with impedance mismatch, e.g. null values, lists with multiple types of values, etc?

