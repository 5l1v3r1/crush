Regex replacement:

# Replace file column in-place using regex
ls | select '*' file={ re{a(b*)c} ~ $file "A\\1B"}

Modes:

re".*"   # Regex
***.txt  # Glob
{ls}     # Closure
(ls)     # Command substitution

Aggregating streams:

find . | group %size | aggr group={count}
find . | group %user | aggr group={sum %size}

Graph/Tree data:

Is there a nice way to represent and visualize graph data such as trees that makes sense for crush?
Could be useful for showing a tree view of processes (ps), file trees (find, du), etc.

* Should this be represented by a special type of tree-struct or just use regular structs with members of the same type? The latter can't represent cycles.
* What additional primitives are needed to efficiently manipulate tree data?

Smoothing out the rough edges:

* boolean flags supported using --foo, equivalent to foo=true
* External commands need to be adapted to not be annoying

Example invocations:
    git:status
    git:commit --a m="This is a commit message"
    git:add .
    ls %.txt
    cd foo
    cd ..
    cd 'My Documents'
    find root/etc
    1 + 2 * 4 # 9
    math:sin 3
    1 + 3.3 # 4.4

Custom types:

Point := (struct)

Point:len={
    ||
    math.sqrt this:x*this:x + this:y*this:y + this:z*this:z
}

Point:__add__={

}

p := (new Point x=1 y=2 z=3)
p:len
