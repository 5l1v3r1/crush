use std::str::FromStr;
use crate::lang::ast::*;

grammar;

pub JobList: JobListNode = {
  OptionalSeparator => JobListNode {jobs: Vec::new()},
  <l:NonEmptyJobList> OptionalSeparator => l,
};

OptionalSeparator: () = {
    => (),
    Separator => (),
}

NonEmptyJobList: JobListNode = {
  <mut l:NonEmptyJobList> Separator <j:Job> =>  {l.jobs.push(j); l},
  <j:Job> => JobListNode {jobs: vec![j]},
};

Job: JobNode = {
    <c:Command> => JobNode{commands: vec![c]},
    <mut j:Job> "|" OptionalSeparator <c:Command> => {j.commands.push(c); j}
};

Command: CommandNode = {
  <a:Assignment> => CommandNode{expressions: vec![a]},
  <mut c: Command> <a:Assignment> => {c.expressions.push(a); c}
};

Assignment: AssignmentNode = {
  <i: Item> "=" <e: Assignment> => AssignmentNode::Assignment(i, Box::new(e)),
  <i: Item> ":=" <e: Assignment> => AssignmentNode::Declaration(i, Box::new(e)),
  <a: Logical> => AssignmentNode::Logical(a),
}

Logical: LogicalNode = {
    <c: Comparison> => LogicalNode::Comparison(c),
    <l: Logical> <op: LogicalOperator> <c: Comparison> => LogicalNode::LogicalOperation(Box::new(l), Box::from(op), c),
}

Comparison: ComparisonNode = {
    <t: Term> => ComparisonNode::Term(t),
    <c: Comparison> <op: ComparisonOperator> <t: Term> => ComparisonNode::Comparison(Box::new(c), Box::from(op), t),
}

Term: TermNode = {
    <f: Factor> => TermNode::Factor(f),
    <t: Term> <op: TermOperator> <f: Factor> => TermNode::Term(Box::new(t), Box::from(op), f),
}

Factor: FactorNode = {
    <u: Unary> => FactorNode::Unary(u),
    <f: Factor> <op: FactorOperator> <u: Unary> => FactorNode::Factor(Box::new(f), Box::from(op), u),
}

Unary: UnaryNode = {
    <i: Item> => UnaryNode::Item(i),
    <op: UnaryOperator> <u: Unary> => UnaryNode::Unary(Box::from(op), Box::new(u)),
}

Item: ItemNode = {
    <l: Label> => ItemNode::Label(Box::from(l)),
    <l: Regex> => ItemNode::Regex(Box::from(&l[3..l.len()-1])),
    <f: Field> => ItemNode::Field(Box::from(f)),
    <g: Glob> => ItemNode::Glob(Box::from(&g[2..])),
    <l: QuotedLabel> => ItemNode::Label(Box::from(l)),
    <s: QuotedString> => ItemNode::String(Box::from(s)),
    <s:Integer> => ItemNode::Integer(i128::from_str(s.replace("_", "").as_str()).unwrap()),
    <s:Float> => ItemNode::Float(f64::from_str(s.replace("_", "").as_str()).unwrap()),
    <i: Item> "[" <e: Assignment> "]" => ItemNode::GetItem(Box::new(i), Box::new(e)),
    <i: Item> ":" <l: Label> => ItemNode::GetAttr(Box::new(i), Box::from(l)),
    <i: Item> "/" <l: Label> => ItemNode::Path(Box::new(i), Box::from(l)),
    "{" <l: NonEmptyJobList> "}" => ItemNode::Closure(l),
    "(" <j:Job> ")" => ItemNode::Substitution(j),
}

match {
    r"(and|or)" => LogicalOperator,
} else {
    r"( |\t)+" => { },
    r"#[^\n]*" => { },
    r"(>|<|>=|<=|==|!=|=~|!~)" => ComparisonOperator,
    "!" => UnaryOperator,
    r"(\*|//)" => FactorOperator,
    r"(\+|-)" => TermOperator,
    r#""([^\\"]|\\.)*""# => QuotedString,
    r"\*\*([^ \n]|\\.)*" => Glob,
    r"%[\._a-zA-Z][\._a-zA-Z0-9]*" => Field,
    r#"'([^\\']|\\.)*'"# => QuotedLabel,
    r#"re"([^"]|\\.)*""# => Regex,
    r"[\._a-zA-Z][\._a-zA-Z0-9]*" => Label,
    r"(;|\n)( |\t|;|\n|#[^\n]*)*" => Separator,
    r"[0-9][0-9_]*" => Integer,
    r"[0-9][0-9_]*\.[0-9_]+" => Float,
    _
}
