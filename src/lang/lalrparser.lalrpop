use std::str::FromStr;
use crate::lang::ast::*;
use crate::lang::command::Parameter;
use crate::lang::value::{ValueDefinition, Value, ValueType};

grammar;

pub JobList: JobListNode = {
  Separator? => JobListNode {jobs: Vec::new()},
  <l:NonEmptyJobList> Separator? => l,
};

NonEmptyJobList: JobListNode = {
  <mut l:NonEmptyJobList> Separator <j:Job> =>  {l.jobs.push(j); l},
  Job => JobListNode {jobs: vec![<>]},
};

Job: JobNode = {
    Command => JobNode{commands: vec![<>]},
    <mut j:Job> "|" Separator? <c:Command> => {j.commands.push(c); j}
};

Command: CommandNode = {
  Assignment => CommandNode{expressions: vec![<>]},
  <mut c: Command> <a:Assignment> => {c.expressions.push(a); c}
};

Assignment: AssignmentNode = {
  <i: Item> "=" <e: Assignment> => AssignmentNode::Assignment(i, Box::new(e)),
  <i: Item> ":=" <e: Assignment> => AssignmentNode::Declaration(i, Box::new(e)),
  Logical => AssignmentNode::Logical(<>),
}

Logical: LogicalNode = {
    Comparison => LogicalNode::Comparison(<>),
    <l: Logical> <op: LogicalOperator> <c: Comparison> => LogicalNode::LogicalOperation(Box::from(l), Box::from(op), c),
}

Comparison: ComparisonNode = {
    Term => ComparisonNode::Term(<>),
    <c: Comparison> <op: ComparisonOperator> <t: Term> => ComparisonNode::Comparison(Box::from(c), Box::from(op), t),
    <c: Comparison> <op: ReplaceOperator> <t1: Term> <t2: Term> => ComparisonNode::Replace(Box::from(c), Box::from(op), t1, t2)
}

Term: TermNode = {
    Factor => TermNode::Factor(<>),
    <t: Term> <op: TermOperator> <f: Factor> => TermNode::Term(Box::from(t), Box::from(op), f),
}

Factor: FactorNode = {
    Unary => FactorNode::Unary(<>),
    <f: Factor> <op: FactorOperator> <u: Unary> => FactorNode::Factor(Box::from(f), Box::from(op), u),
}

Unary: UnaryNode = {
    Item => UnaryNode::Item(<>),
    "!" <u: Unary> => UnaryNode::Unary(Box::from("!"), Box::from(u)),
    "@" <u: Unary> => UnaryNode::Unary(Box::from("@"), Box::from(u)),
    "@@" <u: Unary> => UnaryNode::Unary(Box::from("@@"), Box::from(u)),
}

Signature: Option<Vec<ParameterNode>> = {
    => None,
    "|" "|" => Some(vec![]),
    "|" <s: ParameterList> "|" => Some(s),
}

ParameterList: Vec<ParameterNode> = {
    Parameter => vec![<>],
    <mut l: ParameterList> Separator? <p: Parameter> => {l.push(p); l},
}

Parameter: ParameterNode = {
    <l: Label> <d: Default> => ParameterNode::Parameter(Box::from(l), ValueDefinition::Value(Value::Type(ValueType::Any)), d),
    <n: Label> ":" <t: Label> <d: Default> => ParameterNode::Parameter(Box::from(n), ValueDefinition::Label(Box::from(t)), d),
    "@" <l: Label> => ParameterNode::Unnamed(Box::from(l)),
    "@@" <l: Label> => ParameterNode::Named(Box::from(l)),
}

Default: Option<LogicalNode> = {
    => None,
    "=" <l: Logical> => Some(l),
}

Item: ItemNode = {
    Label => ItemNode::Label(Box::from(<>)),
    <l: Regex> => ItemNode::Regex(Box::from(&l[3..l.len()-1])),
    Field => ItemNode::Field(Box::from(<>)),
    <g: Glob> => ItemNode::Glob(Box::from(&g[2..])),
    QuotedLabel => ItemNode::Label(Box::from(<>)),
    QuotedString => ItemNode::String(Box::from(<>)),
    Integer => ItemNode::Integer(i128::from_str(<>.replace("_", "").as_str()).unwrap()),
    Float => ItemNode::Float(f64::from_str(<>.replace("_", "").as_str()).unwrap()),
    <i: Item> "[" <e: Assignment> "]" => ItemNode::GetItem(Box::new(i), Box::from(e)),
    <i: Item> ":" <l: Label> => ItemNode::GetAttr(Box::from(i), Box::from(l)),
    <i: Item> "/" <l: Label> => ItemNode::Path(Box::from(i), Box::from(l)),
    "{" <s: Signature> <l: NonEmptyJobList> "}" => ItemNode::Closure(s, l),
    "(" <j:Job> ")" => ItemNode::Substitution(j),
}

match {
    r"(and|or)" => LogicalOperator,
    r"as" => CastOperator,
} else {
    r"( |\t)+" => {},
    r"#[^\n]*" => {},
    r"(>|<|>=|<=|==|!=|=~|!~)" => ComparisonOperator,
    r"(\*|//)" => FactorOperator,
    r"(~~|~)" => ReplaceOperator,
    r"(\+|-)" => TermOperator,
    r#""([^\\"]|\\.)*""# => QuotedString,
    r"\*\*([^ \n]|\\.)*" => Glob,
    r"%[\._a-zA-Z][\._a-zA-Z0-9]*" => Field,
    r#"'([^\\']|\\.)*'"# => QuotedLabel,
    r#"re"([^"]|\\.)*""# => Regex,
    r"[\._a-zA-Z][\._a-zA-Z0-9]*" => Label,
    r"(;|\n)( |\t|;|\n|#[^\n]*)*" => Separator,
    r"[0-9][0-9_]*" => Integer,
    r"[0-9][0-9_]*\.[0-9_]+" => Float,
    _
}
